#!/usr/bin/env python3
"""List repositories that have file content.

Smart display the output of `git annex whereis` with specified depth
similar to `du`. A summary with file numbers for directories up to the
specified depth is displayed.

Results are cached so subsequent requests should be fast. The cache is
invalidated when the git-annex branch moves.

"""
import sys
import os
import argparse
import json
import subprocess
import signal


class ZeroDict(dict):
    """Zero based counter."""

    def __missing__(self, key):
        """Return 0 to start the counter."""
        return 0


class Whereis():
    """Handle whereis requests."""

    def __init__(self):
        """Initialise the cache."""
        self.cache = {}
        self.cache_file = cache_file_location()
        self.load_cache()

    def load_cache(self):
        """Load cache file."""
        if os.path.isfile(self.cache_file):
            with open(self.cache_file) as file:
                self.cache = json.load(file)

    def save_cache(self):
        """Save cache file."""
        tmp_file = self.cache_file + ".tmp"
        with open(tmp_file, "w") as file:
            json.dump(self.cache, file)
        os.rename(tmp_file, self.cache_file)

    def sigint(self):
        """Save cache and exit on SIGINT."""
        self.save_cache()
        sys.exit(1)

    def whereis(self, path, remaining_depth):
        """List the repositories that have content and print (by depth)."""
        # Check that the file is not ignored by git
        ignored = check_ignore(path)
        if (len(ignored) > 0 or
                os.path.basename(os.path.normpath(path)) == ".git"):
            return ZeroDict()

        # For file, run git annex whereis and return the result
        if os.path.isfile(path):
            where = self.where(path)
            if remaining_depth >= 0:
                print("{:s}:".format(path))
                for remote in where:
                    print("    {:s}".format(remote))
            return ZeroDict({frozenset(where): 1})

        # Recurse into directory contents
        wheres = ZeroDict()
        for subpath in os.listdir(path):
            subwhere = self.whereis(os.path.join(path, subpath),
                                    remaining_depth - 1)
            for where, num in subwhere.items():
                wheres[where] += num
        if remaining_depth >= 0:
            print("{:s}:".format(path))
            for where, num in wheres.items():
                print("  {:d} files:".format(num))
                for remote in where:
                    print("    {:s}".format(remote))
        return wheres

    def where(self, path):
        """Get whereis information for file."""
        where_tree = self._where(path)
        # Parse the JSON output
        if where_tree == {}:
            if os.path.islink(path):
                where = {"(symlink)"}
            else:
                where = set()
        else:
            if not where_tree["success"]:
                raise ValueError("whereis error:\n{:s}".format(
                    json.dumps(where_tree)))
            where = {parse_remote(x) for x in where_tree["whereis"]}
        return where

    def _where(self, path):
        """Try to look up whereis info from cache, or ask git-annex."""
        key = lookup_key(path)
        if self.cache.get(key) is None:
            proc = subprocess.Popen(
                ["git", "annex", "whereis", "--json", "{:s}".format(path)],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                universal_newlines=True)
            try:
                outs, _ = proc.communicate()
            except subprocess.TimeoutExpired:
                proc.kill()
                outs, errs = proc.communicate()
                print(
                    "whereis timeout: {:s}\n"
                    "STDOUT:\n{:s}\nSTDERR:\n{:s}\n".format(
                        path, outs, errs))
                raise
            # Sanitize the JSON output
            outs = outs.replace("\n", "").replace("\t", "")
            if len(outs) != 0:
                self.cache[key] = json.loads(outs)
            else:
                self.cache[key] = {}
        return self.cache[key]


def check_ignore(path):
    """Check whether path is ignored by git."""
    proc = subprocess.Popen(
        ["git", "check-ignore", "{:s}".format(path)],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        universal_newlines=True)
    try:
        outs, _ = proc.communicate(timeout=10)
    except subprocess.TimeoutExpired:
        proc.kill()
        outs, errs = proc.communicate()
        print(
            "check-ignore timeout: {:s}\n"
            "STDOUT:\n{:s}\nSTDERR:\n{:s}\n".format(
                path, outs, errs))
        raise
    return outs


def lookup_key(path):
    """Look up git-annex key for path."""
    proc = subprocess.Popen(
        ["git", "annex", "lookupkey", "{:s}".format(path)],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        universal_newlines=True)
    try:
        outs, _ = proc.communicate(timeout=10)
    except subprocess.TimeoutExpired:
        proc.kill()
        outs, errs = proc.communicate()
        print(
            "lookupkey timeout: {:s}\n"
            "STDOUT:\n{:s}\nSTDERR:\n{:s}\n".format(
                path, outs, errs))
        raise
    return outs.strip()


def parse_remote(remote):
    """Parse the dictionary from the 'whereis' list to string"""
    out = "{:s} -- {:s}".format(remote["uuid"], remote["description"])
    if remote["here"]:
        out += " (here)"
    return out


def cache_file_location():
    """Get cache file location."""
    # Find relative path to git directory
    proc = subprocess.Popen(
        ["git", "rev-parse", "--git-dir"],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        universal_newlines=True)
    try:
        outs, _ = proc.communicate(timeout=10)
    except subprocess.TimeoutExpired:
        outs, errs = proc.communicate()
        print(
            "rev-parse timeout:\n"
            "STDOUT:\n{:s}\nSTDERR:\n{:s}\n".format(
                outs, errs))
        raise
    # Cache file goes in the annex/misctmp directory
    cdir = os.path.join(outs.strip(), "annex/misctmp")
    assert os.path.exists(cdir)
    # Find last git-annex branch commit SHA
    proc = subprocess.Popen(
        ["git", "rev-list", "-1", "git-annex"],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        universal_newlines=True)
    try:
        outs, _ = proc.communicate(timeout=10)
    except subprocess.TimeoutExpired:
        outs, errs = proc.communicate()
        print(
            "rev-list timeout:\n"
            "STDOUT:\n{:s}\nSTDERR:\n{:s}\n".format(
                outs, errs))
        raise
    cfile = "whereis-" + outs.strip() + ".json"
    return os.path.join(cdir, cfile)


def main():
    """Parse the arguments and list repositories."""
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("-d", "--depth", metavar="N", type=int, default=1,
                        help="""Display an entry for all files and directories
                        N directories deep.""")
    parser.add_argument("path", nargs="?", default=".",
                        help="Display whereis information for path")
    args = parser.parse_args()
    whereis = Whereis()
    signal.signal(signal.SIGINT, lambda signal, frame: whereis.sigint())
    whereis.whereis(args.path, args.depth)
    whereis.save_cache()


if __name__ == "__main__":
    main()
